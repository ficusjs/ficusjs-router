{"version":3,"file":"router.mjs","sources":["../src/util/wait-for.mjs","../src/util/is-promise.mjs","../src/util/object-has-key.mjs","../src/util/element-empty.mjs","../src/util/render-outlet.mjs","../src/util/is-element.mjs","../src/util/element-from-string.mjs","../src/util/flatten-routes.mjs","../src/util/slashes.mjs","../src/util/add-matcher-to-route.mjs","../src/router.mjs","../src/util/emit.mjs"],"sourcesContent":["/**\n * A promise based function to wait for a condition to pass or timeout - whichever is the soonest\n * @param {Function} test\n * @param {number} timeoutInMilliseconds\n * @returns {Promise<unknown>}\n */\nexport const waitFor = (test = () => true, timeoutInMilliseconds = 10000) => new Promise((resolve, reject) => {\n  const check = () => {\n    const result = test()\n    if (result) {\n      resolve(result)\n    } else if ((timeoutInMilliseconds -= 100) < 0) {\n      reject(new Error('Timed out waiting!'))\n    } else {\n      setTimeout(check, 100)\n    }\n  }\n  setTimeout(check, 100)\n})\n","export function isPromise (obj) {\n  return (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n","export function hasKey (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n","/**\n * Function to empty an element\n * @param {Element} el\n */\nexport function elementEmpty (el) {\n  while (el.firstChild) el.removeChild(el.firstChild)\n}\n","/**\n * Function to render a router outlet\n * @param {string|HTMLElement} what A component tag, HTML snippet or DOM element\n * @param {HTMLElement|string} where An element to render into\n */\nimport { elementFromString } from './element-from-string.mjs'\nimport { isElement } from './is-element.mjs'\nimport { elementEmpty } from './element-empty.mjs'\n\nexport function renderOutlet (what, where) {\n  // check for an outlet\n  const outlet = typeof where === 'string' ? document.querySelector(where) : where\n  if (!outlet) {\n    console.warn(`Unable to find outlet: ${where}`)\n    return\n  }\n\n  // decide what to render into the outlet\n  let element\n  if (isElement(what)) {\n    element = what\n  } else {\n    const isComponent = window.customElements.get(what)\n    if (isComponent) {\n      element = document.createElement(what)\n    } else {\n      element = elementFromString(what)\n    }\n  }\n\n  elementEmpty(outlet)\n  outlet.appendChild(element)\n\n  // set the data attribute so we can clear the outlet later\n  const dro = 'data-router-outlet'\n  if (!outlet.hasAttribute(dro)) outlet.setAttribute(dro, '')\n}\n","/* global Element HTMLElement */\n\n/**\n * Function to assert for a DOM element\n * @param {Element|HTMLElement} element\n * @returns {boolean}\n */\nexport function isElement (element) {\n  return element instanceof Element || element instanceof HTMLElement\n}\n","/**\n * Function to create an element from an HTML string\n * @param {string} html The HTML string\n * @returns {HTMLElement} The created element\n * @example\n * elementFromString(`<div>\n *   <h3>A 3rd level header</h3>\n *   <p>A paragraph</p>\n * </div>`)\n */\nexport function elementFromString (html) {\n  const div = document.createElement('div')\n  div.innerHTML = html.trim()\n  return div.firstChild\n}\n","class Stack extends Array {\n  peek () {\n    return this[this.length - 1]\n  }\n}\n\nfunction flatten (stack, parentRouteStack, routes, clearParentRouteStack = true) {\n  routes.forEach(route => {\n    if (route.children) {\n      flattenChildren(stack, parentRouteStack, route)\n    } else {\n      const nr = copyRouteAndAdjustPath(route, parentRouteStack)\n      stack.push(nr)\n    }\n    if (clearParentRouteStack) {\n      parentRouteStack.splice(0, parentRouteStack.length)\n    }\n  })\n}\n\nfunction flattenChildren (stack, parentRouteStack, route) {\n  let children = [...route.children]\n  let newRoute\n  if (route.action || route.component) {\n    newRoute = { ...route }\n    delete newRoute.children\n  } else {\n    const emptyRoute = children.find(r => r.path === '')\n    if (emptyRoute) {\n      newRoute = { ...emptyRoute }\n      newRoute.path = route.path\n      delete newRoute.children\n      children = children.filter(r => r.path !== '')\n    }\n  }\n  const nr = copyRouteAndAdjustPath(newRoute, parentRouteStack)\n  stack.push(nr)\n  parentRouteStack.push(nr)\n  flatten(stack, parentRouteStack, children, false)\n}\n\nfunction copyRouteAndAdjustPath (route, parentRouteStack) {\n  const nr = { ...route }\n  const last = parentRouteStack.peek()\n  if (last) {\n    nr.path = `${last.path}${nr.path}`\n  }\n  return nr\n}\n\nexport function flattenRoutes (routes) {\n  const stack = new Stack()\n  const parentRouteStack = new Stack()\n  flatten(stack, parentRouteStack, routes)\n  return stack\n}\n","export function stripTrailingSlash (path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path\n}\n","import { stripTrailingSlash } from './slashes.mjs'\n\nexport function addMatcherToRoute (route) {\n  const newRoute = {\n    ...route,\n    matcher: (path) => {\n      return stripTrailingSlash(route.path) === stripTrailingSlash(path) ? path : undefined\n    }\n  }\n  if (route.component && !route.action) newRoute.action = () => route.component\n  if (/:[^/]+/.test(route.path)) {\n    const keys = route.path.match(/(:[^/]+)/gm)\n    if (keys && keys.length > 0) {\n      newRoute.urlParamKeys = keys.map(k => k.substring(1))\n    }\n    const pathRegexStr = stripTrailingSlash(route.path.replace(/:[^/]+/g, '([^/]+)'))\n    newRoute.pathRegex = new RegExp(`^${pathRegexStr}$`)\n    newRoute.pathRegexCapture = new RegExp(pathRegexStr, 'gm')\n    newRoute.matcher = (path) => {\n      if (newRoute.pathRegex.test(path)) {\n        const params = {}\n        let v\n        while ((v = newRoute.pathRegexCapture.exec(path)) !== null) {\n          if (v && v.length === newRoute.urlParamKeys.length + 1) {\n            const nv = v.slice(1)\n            for (let i = 0; i < nv.length; i++) {\n              params[newRoute.urlParamKeys[i]] = nv[i]\n            }\n          }\n        }\n        return params\n      }\n      return undefined\n    }\n  }\n  return newRoute\n}\n","import { waitFor } from './util/wait-for.mjs'\nimport { isPromise } from './util/is-promise.mjs'\nimport { hasKey } from './util/object-has-key.mjs'\nimport { elementEmpty } from './util/element-empty.mjs'\nimport { renderOutlet } from './util/render-outlet.mjs'\nimport { flattenRoutes } from './util/flatten-routes.mjs'\nimport { emit } from './util/emit.mjs'\nimport { addMatcherToRoute } from './util/add-matcher-to-route.mjs'\n\nclass UrlSearchOrHashParams {\n  constructor (url) {\n    this.urlParamMap = {}\n    let paramUrl\n    let urlHash\n    let paramPairs = []\n\n    if (url.includes('?')) {\n      paramUrl = url.substring(url.indexOf('?') + 1)\n      if (paramUrl.includes('#')) {\n        paramUrl = paramUrl.substring(0, paramUrl.indexOf('#'))\n        urlHash = paramUrl.substring(paramUrl.indexOf('#') + 1)\n      }\n    } else if (url.includes('#')) {\n      paramUrl = ''\n      urlHash = url.substring(url.indexOf('#') + 1, url.length)\n    }\n\n    paramPairs = paramUrl ? paramUrl.split('&') : []\n\n    if (urlHash && urlHash.includes('&') && urlHash.includes('=')) {\n      paramPairs = [...paramPairs, ...urlHash.split('&')]\n    }\n\n    for (let i = 0; i < paramPairs.length; i++) {\n      const paramComponents = paramPairs[i].split('=')\n      if (paramComponents.length === 2) {\n        this.urlParamMap[paramComponents[0]] = this._esc(decodeURIComponent(paramComponents[1]))\n      }\n    }\n  }\n\n  entries () {\n    let entries = []\n    for (const key in this.urlParamMap) {\n      if (this.has(key)) {\n        entries.push([key, this.urlParamMap[key]])\n      }\n    }\n\n    entries = entries.sort(function (entryA, entryB) {\n      if (entryA[0].toLowerCase() > entryB[0].toLowerCase()) {\n        return 1\n      }\n      if (entryA[0].toLowerCase() < entryB[0].toLowerCase()) {\n        return -1\n      }\n      return 0\n    })\n\n    return entries\n  }\n\n  remove (key) {\n    delete this.urlParamMap[key]\n  }\n\n  get (key) {\n    return this.urlParamMap[key]\n  }\n\n  has (key) {\n    // eslint-disable-next-line no-prototype-builtins\n    return this.urlParamMap.hasOwnProperty(key)\n  }\n\n  keys () {\n    const keys = []\n    for (const key in this.urlParamMap) {\n      if (this.has(key)) {\n        keys.push(key)\n      }\n    }\n    return keys\n  }\n\n  set (key, val) {\n    this.urlParamMap[key] = val\n  }\n\n  toString () {\n    let paramsString = ''\n    const entries = this.entries()\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i]\n      if (this.has(entry[0])) {\n        paramsString += '&' + entry[0] + '=' + encodeURIComponent(this._unesc(entry[1]))\n      }\n    }\n    return paramsString.substring(1)\n  }\n\n  values () {\n    const values = []\n    for (const key in this.urlParamMap) {\n      if (this.has(key)) {\n        values.push(this.urlParamMap[key])\n      }\n    }\n    return values\n  }\n\n  _esc (s) {\n    return String(s)\n      .replace(/</g, '&lt;')\n      .replace(/'/g, '&#39;')\n      .replace(/\"/g, '&quot;')\n      .replace(/>/g, '&gt;')\n      .replace(/&/g, '&amp;')\n  }\n\n  _unesc (s) {\n    return String(s)\n      .replace(/&lt;/g, '<')\n      .replace(/&#39;/g, '\\'')\n      .replace(/&quot;/g, '\"')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&')\n  }\n}\n\nclass Stack {\n  constructor () {\n    this.items = []\n  }\n\n  push (element) {\n    this.items.push(element)\n  }\n\n  pop () {\n    this.items.pop()\n  }\n\n  peek () {\n    return this.items[this.items.length - 1]\n  }\n\n  isEmpty () {\n    return this.items.length === 0\n  }\n\n  clear () {\n    this.items = []\n  }\n\n  size () {\n    return this.items.length\n  }\n}\n\nclass Router {\n  constructor (routes, rootOutletSelector, options) {\n    if (typeof window !== 'undefined' && window.__ficusjs__ && window.__ficusjs__.router) {\n      return window.__ficusjs__.router\n    }\n\n    this._rootOutletSelector = rootOutletSelector\n\n    // create stack\n    this.stack = new Stack()\n\n    // process routes\n    this._routes = this._processRoutes(routes)\n\n    // process router options\n    this._routerOptions = this._processOptions(options)\n\n    // create an outlet cache\n    this._outletCache = new WeakMap()\n\n    // add the popstate event listener for history changes\n    if (typeof window !== 'undefined') {\n      window.addEventListener('popstate', () => {\n        this._findAndRenderRoute(this.location)\n          .then(() => this.stack.pop())\n          .catch(e => {\n            this._renderError(this.location, e)\n            throw e\n          })\n      })\n      window.__ficusjs__ = window.__ficusjs__ || {}\n      window.__ficusjs__.router = window.__ficusjs__.router || this\n    }\n  }\n\n  // getter for the location property\n  get location () {\n    let loc\n    if (typeof window !== 'undefined') {\n      loc = {\n        host: window.location.host,\n        protocol: window.location.protocol,\n        pathname: window.location.pathname,\n        hash: window.location.hash,\n        href: window.location.href,\n        search: window.location.search,\n        state: window.history.state\n      }\n      if (this._routerOptions.mode === 'hash') {\n        loc.pathname = this._getHashPathname()\n        loc.hash = ''\n      }\n    }\n    return loc\n  }\n\n  // getter for the options\n  get options () {\n    return this._routerOptions\n  }\n\n  /**\n   * Set the router options\n   * @param {Object|undefined} options\n   */\n  setOptions (options = {}) {\n    this._routerOptions = this._processOptions(options)\n  }\n\n  /**\n   * Add more routes to the router\n   * @param {Routes} routes\n   */\n  addRoutes (routes) {\n    this._routes = [...this._routes, ...this._processRoutes(routes)]\n  }\n\n  /**\n   * Check if the path name matches a route\n   * @param {string} pathname\n   * @returns {boolean}\n   */\n  hasRoute (pathname) {\n    return !!this._findRoute(pathname)\n  }\n\n  /**\n   * Get the query string params as an object\n   * @param {RouteLocation} location\n   * @returns {Object|undefined}\n   * @private\n   */\n  _getQueryStringParams (location) {\n    return Object.fromEntries(new UrlSearchOrHashParams(location.href).entries())\n  }\n\n  /**\n   * Get the URL params as an object\n   * @param {RouteLocation} location\n   * @returns {Object|undefined}\n   * @private\n   */\n  _getUrlParams (location, route) {\n    const params = route.matcher(location.pathname)\n    return typeof params === 'string' ? undefined : params\n  }\n\n  /**\n   * Match a route by pathname\n   * @param {String} pathname\n   * @returns {Route}\n   * @private\n   */\n  _findRoute (pathname) {\n    return this._routes.find(r => r.matcher(pathname) !== undefined)\n  }\n\n  /**\n   * Return the hash pathname\n   * @returns {string}\n   * @private\n   */\n  _getHashPathname () {\n    let pathname = window.location.hash.substring(1)\n    if (pathname === '') pathname = '/'\n    return pathname\n  }\n\n  /**\n   * Process the routes\n   * @param {Array} routes\n   * @returns {Array}\n   * @private\n   */\n  _processRoutes (routes) {\n    return flattenRoutes(routes).map(r => addMatcherToRoute(r))\n  }\n\n  /**\n   * Process router options\n   * @param {RouterOptions} opts\n   * @returns {RouterOptions}\n   * @private\n   */\n  _processOptions (opts = {}) {\n    const that = this\n    const options = {\n      mode: 'history', // or 'hash'\n      autoStart: true,\n      changeHistoryState: true,\n      warnOnMissingOutlets: false,\n      ...opts\n    }\n\n    // check for existence of the resolveRoute function\n    if (!options.resolveRoute) {\n      return {\n        ...options,\n        resolveRoute (context, params) {\n          if (context.route && typeof context.route.action === 'function') {\n            return {\n              template: new Promise((resolve, reject) => {\n                const template = context.route.action(context, params)\n                resolve(template)\n              }).catch(e => {\n                that._renderError(context.location, e)\n                throw e\n              }),\n              outlets: context.route.outlets\n            }\n          }\n        }\n      }\n    } else if (options.resolveRoute) {\n      const routeResolver = options.resolveRoute\n      return {\n        ...options,\n        resolveRoute (context, params) {\n          return routeResolver(context, params)\n        }\n      }\n    }\n    return options\n  }\n\n  /**\n   * Render an template for a route\n   * @param {RouteLocation} location\n   * @param {object} context\n   * @param {ActionResult} result\n   * @param {Outlets} outlets\n   * @returns {Promise}\n   * @private\n   */\n  _render (location, context, result, outlets = {}) {\n    return isPromise(result)\n      ? result.then(template => this._performRender(location, context, template, outlets))\n      : this._performRender(location, context, result, outlets)\n  }\n\n  /**\n   * Perform a render\n   * @param {RouteLocation} location\n   * @param {object} context\n   * @param {ActionResult} template\n   * @param {Outlets} outlets\n   * @returns {Promise}\n   * @private\n   */\n  _performRender (location, context, template, outlets) {\n    // is the template a redirect?\n    if (typeof template === 'object' && template.redirect) {\n      return Promise.resolve(template)\n    }\n\n    // is the action result an Error?\n    if (template instanceof Error) {\n      this._renderError(location, template)\n      return Promise.resolve(true)\n    }\n\n    // is the action result a false value?\n    if (template === false) return Promise.resolve(false)\n\n    return waitFor(() => document.querySelector(this._rootOutletSelector))\n      .then(() => {\n        const routerOutlet = document.querySelector(this._rootOutletSelector)\n        const ok = Object.keys(outlets)\n\n        // find any outlets and clear them if they're not a defined outlet for the route\n        const namedOutlets = document.querySelectorAll('[data-router-outlet]:not([sticky])')\n        if (namedOutlets.length) {\n          [...namedOutlets].filter(o => o !== routerOutlet).forEach(o => elementEmpty(o))\n        }\n\n        // render the template into the outlet component\n        this._renderIntoOutlet(template, routerOutlet)\n\n        // do we have named outlets to render?\n        if (ok.length) {\n          return Promise.all(\n            ok.map(k => waitFor(() => {\n              const namedOutlets = document.querySelectorAll(k)\n              return namedOutlets.length > 0 ? namedOutlets : false\n            })\n              .then(allOutlets => {\n                const result = outlets[k](context, context && context.params)\n                isPromise(result)\n                  ? result.then(template => this._renderIntoAllOutlets(template, allOutlets))\n                  : this._renderIntoAllOutlets(result, allOutlets)\n              })\n              .catch(e => this._routerOptions.warnOnMissingOutlets && console.warn(e)))\n          ).then(() => true)\n        } else {\n          return Promise.resolve(true)\n        }\n      })\n  }\n\n  /**\n   * Render a template into a router outlet\n   * @param {ActionResult} result\n   * @param {HTMLElement} routerOutlet\n   * @private\n   */\n  _renderIntoOutlet (result, routerOutlet) {\n    if (!result) return\n    if (this._isSameOutletContent(result, routerOutlet)) {\n      return\n    }\n    renderOutlet(result, routerOutlet)\n    this._outletCache.set(routerOutlet, result)\n    this._emitRouterOutletChangeEvent(routerOutlet)\n  }\n\n  /**\n   * Render a template into multiple outlets\n   * @param {ActionResult} result\n   * @param {Array<HTMLElement>} routerOutlets\n   * @private\n   */\n  _renderIntoAllOutlets (result, routerOutlets) {\n    for (let i = 0; i < routerOutlets.length; i++) {\n      const ro = routerOutlets[i]\n      this._renderIntoOutlet(result, ro)\n    }\n  }\n\n  /**\n   * Emit a router outlet change event\n   * @private\n   * @param {HTMLElement} routerOutlet the router outlet to emit the change event for\n   */\n  _emitRouterOutletChangeEvent (routerOutlet) {\n    emit(routerOutlet, 'outlet-change', {\n      detail: {\n        outlet: routerOutlet\n      }\n    })\n  }\n\n  /**\n   * Check if what has already been rendered is the same content\n   * @param {ActionResult} result\n   * @param {HTMLElement} routerOutlet\n   * @returns {boolean}\n   * @private\n   */\n  _isSameOutletContent (result, routerOutlet) {\n    if (typeof result === 'string' && this._outletCache.has(routerOutlet) && this._outletCache.get(routerOutlet) === result) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Navigate to a location\n   * @param {string|RouteLocation} location\n   * @param {object|undefined} state\n   * @returns {Promise}\n   */\n  push (location, state) {\n    return this._navigate(location, state)\n  }\n\n  /**\n   * Replace the current location\n   * @param {string|RouteLocation} location\n   * @param {object|undefined} state\n   * @returns {Promise}\n   */\n  replace (location, state) {\n    return this._navigate(location, state, true)\n  }\n\n  /**\n   * Navigate to a route\n   * This involves finding and rendering a route and then setting the history state.\n   *\n   * If an errorHandler is supplied with the router options then it is invoked with\n   * the error and context arguments and the resulting template is rendered. If no errorHandler\n   * is specified then a generic error message is rendered\n   * @param {string|RouteLocation} location\n   * @param {object|undefined} state\n   * @param {boolean} replaceHistory\n   * @returns {Promise}\n   * @private\n   */\n  _navigate (location, state, replaceHistory = false) {\n    const thisLocation = this._normalizeLocation(location)\n\n    // ignore the current URL if we are not replacing history\n    if (!replaceHistory && thisLocation.pathname === this.location.pathname) {\n      return Promise.resolve()\n    }\n\n    // find route\n    const { actionResult, context } = this._resolveRoute(thisLocation)\n\n    if (actionResult == null) {\n      this._routerOptions.changeHistoryState && this._setState(thisLocation.href, state, replaceHistory)\n      const err = new Error('not_found')\n      this._renderError(thisLocation, err)\n      return Promise.reject(err)\n    }\n\n    // is the action result a redirect?\n    if (typeof actionResult === 'object' && actionResult.redirect) {\n      const state = { from: location }\n      return actionResult.redirect !== this.location.pathname ? this.push(actionResult.redirect, state) : Promise.resolve()\n    }\n\n    // is the action result an Error?\n    if (actionResult instanceof Error) {\n      this._routerOptions.changeHistoryState && this._setState(thisLocation.href, state, replaceHistory)\n      this._renderError(thisLocation, actionResult)\n      return Promise.reject(actionResult)\n    }\n\n    // is the action result a false value?\n    if (actionResult === false) return Promise.resolve()\n\n    // render route\n    return this._renderActionResult(thisLocation, context, actionResult, state, replaceHistory)\n      .then(result => {\n        if (typeof result === 'object' && result.redirect) {\n          const state = { from: thisLocation.href }\n          return this.push(result.redirect, state)\n        }\n        result && this._routerOptions.changeHistoryState && this._setState(thisLocation.href, state, replaceHistory)\n        return Promise.resolve(result)\n      })\n      .catch(e => {\n        this._renderError(thisLocation, e)\n        throw e\n      })\n  }\n\n  /**\n   * Normalise a location - can be string or location object\n   * @param location\n   * @returns {RouteLocation}\n   * @private\n   */\n  _normalizeLocation (location) {\n    const loc = {\n      host: undefined,\n      protocol: undefined,\n      href: undefined,\n      pathname: undefined,\n      search: undefined,\n      hash: undefined\n    }\n\n    if (typeof location === 'object') {\n      if (this._routerOptions.mode === 'history' && !location.pathname) throw new Error(`Unable to navigate to: ${location}`)\n      let href = location.href || this.location.href\n      loc.pathname = location.pathname || this.location.pathname\n      if (location.search && location.search !== '' && !href.includes(location.search)) {\n        href = `${href}${location.search}`\n        loc.search = location.search\n      }\n      if (location.hash && location.hash !== '' && !href.includes(location.hash)) {\n        href = `${href}${location.hash}`\n        loc.hash = location.hash\n      }\n      loc.hash = location.hash || this.location.hash\n      loc.search = location.search || this.location.search\n      loc.host = location.host || this.location.host\n      loc.protocol = location.protocol || this.location.protocol\n      loc.href = href\n    } else if (typeof location === 'string') {\n      const url = new URL(/^https?:\\/\\//.test(location) ? location : `${window.location.protocol}//${window.location.host}${location}`)\n      loc.host = url.host\n      loc.protocol = url.protocol\n      loc.href = url.href\n      loc.pathname = url.pathname\n      loc.search = url.search\n      loc.hash = url.hash\n      if (location.includes('?')) {\n        loc.pathname = location.substring(0, location.indexOf('?'))\n        loc.search = location.substring(location.indexOf('?'))\n      } else if (location.includes('#')) {\n        loc.pathname = location.substring(0, location.indexOf('#'))\n      }\n    }\n\n    if (this._routerOptions.mode === 'hash') {\n      loc.href = `${window.location.pathname}${loc.search || ''}#${loc.pathname}`\n    }\n\n    return loc\n  }\n\n  /**\n   * Render an action result\n   * @param {RouteLocation} location\n   * @param {object} context\n   * @param {ActionResult} actionResult\n   * @param {object|undefined} state\n   * @param {boolean} replaceHistory\n   * @returns {Promise}\n   * @private\n   */\n  _renderActionResult (location, context, actionResult) {\n    if (hasKey(actionResult, 'template') && hasKey(actionResult, 'outlets')) {\n      const { template, outlets } = actionResult\n      return this._render(location, context, template, outlets)\n    } else {\n      return this._render(location, context, actionResult, {})\n    }\n  }\n\n  /**\n   * Get a route context\n   * @param {Route} route\n   * @param {RouteLocation} location\n   * @returns {RouteContext}\n   * @private\n   */\n  _getRouteContext (route, location) {\n    let params = {\n      ...this._getQueryStringParams(location)\n    }\n    const routeContext = {\n      context: this._routerOptions.context,\n      router: this,\n      route,\n      location,\n      params\n    }\n    if (route) {\n      params = {\n        ...params,\n        ...this._getUrlParams(location, route)\n      }\n      routeContext.params = params\n    }\n    return routeContext\n  }\n\n  /**\n   * Resolve a route\n   * If the resolveRoute function is specified, it is invoked to get the route action result.\n   * If no resolveRoute is defined then the route action result is matched against any defined routes\n   * @param {RouteLocation} pathname\n   * @returns {{actionResult: ActionResult|undefined, context: RouteContext}}\n   * @private\n   */\n  _resolveRoute (location) {\n    const route = this._findRoute(location.pathname)\n    const context = this._getRouteContext(route, location)\n    try {\n      const actionResult = this._routerOptions.resolveRoute(context, context.params)\n      if (actionResult != null) {\n        return { actionResult, context }\n      }\n      if (!route) {\n        return { actionResult: undefined, context }\n      }\n      return { actionResult: route.action(context, context.params), context }\n    } catch (e) {\n      this._renderError(location, e)\n      throw e\n    }\n  }\n\n  /**\n   * Find and render a route\n   * This involves matching a route and then rendering it.\n   * It is wrapped in a Promise so routes can be async and resolved before rendering.\n   * @param {RouteLocation} location\n   * @returns {Promise}\n   * @private\n   */\n  _findAndRenderRoute (location) {\n    // find route\n    const { actionResult, context } = this._resolveRoute(location)\n\n    if (!actionResult) {\n      throw new Error('not_found')\n    }\n\n    return this._renderActionResult(location, context, actionResult)\n  }\n\n  /**\n   * Set the history state\n   * This pushes or replaces the current state\n   * @param {String} path\n   * @param {any} state\n   * @param {Boolean} replace\n   * @private\n   */\n  _setState (path, state, replace = false) {\n    if (replace) {\n      window.history.replaceState(state, null, path)\n    } else {\n      this.stack.push(path)\n      window.history.pushState(state, null, path)\n    }\n  }\n\n  /**\n   * Handle a generic error\n   * @param {RouteLocation} location\n   * @param {Error} error\n   * @private\n   */\n  _renderError (location, error) {\n    console.error(`A router error occurred for location '${location.href}'`, error)\n    if (this._routerOptions.errorHandler) {\n      const err = {\n        message: error.message,\n        status: error.message === 'not_found' ? 404 : 500\n      }\n      const context = this._getRouteContext(this._findRoute(location.pathname), location)\n      const errorTemplate = this._routerOptions.errorHandler(err, context)\n      if (isPromise(errorTemplate)) {\n        errorTemplate\n          .then(template => this._render(location, context, template))\n          .catch(e => this._render(location, context, `<div><strong>Router error from <code>errorHandler</code></strong>: ${e.message}, original error: ${error.message}</div>`))\n      } else {\n        this._render(location, context, errorTemplate)\n      }\n    } else {\n      // use generic error template as a fallback\n      this._render(location, null, `<div><strong>Router error</strong>: ${error.message}</div>`)\n    }\n  }\n\n  /**\n   * Go forwards or backwards n pages in history\n   * @param {Number} n\n   */\n  go (n) {\n    window.history.go(n)\n  }\n\n  /**\n   * Equivalent to clicking back button\n   */\n  goBack () {\n    this.go(-1)\n  }\n\n  /**\n   * Equivalent to clicking forward button\n   */\n  goForward () {\n    this.go(1)\n  }\n\n  /**\n   * Start the router by rendering the route for the current location\n   * @param {string|RouteLocation} location\n   */\n  start (location = this.location) {\n    if (/complete|interactive|loaded/.test(document.readyState)) {\n      // In case DOMContentLoaded was already fired, the document readyState will be one of \"complete\" or \"interactive\" or (nonstandard) \"loaded\"\n      this.replace(location)\n    } else {\n      // In case DOMContentLoaded was not yet fired, use it to run the \"replace\" function when document is read for it\n      document.addEventListener('DOMContentLoaded', () => this.replace(location))\n    }\n  }\n}\n\n/**\n * Function to create a Router class instance\n * @param {Routes} routes\n * @param {string} rootOutletSelector\n * @param {RouterOptions|undefined} options\n * @returns {Router}\n */\nfunction createRouter (routes, rootOutletSelector, options = {}) {\n  const router = new Router(routes, rootOutletSelector, options)\n\n  // render the initial route\n  if (router.options.autoStart) router.start()\n\n  return router\n}\n\n/**\n * Function to get the running Router instance\n * @returns {Router}\n */\nfunction getRouter () {\n  if (typeof window !== 'undefined' && window.__ficusjs__ && window.__ficusjs__.router) {\n    return window.__ficusjs__.router\n  }\n}\n\nexport { createRouter, getRouter, addMatcherToRoute }\n","/* global CustomEvent */\n/**\n * Function to emit an event on an element\n * @param {Node} elem The element that emits the event\n * @param {string} name The name of the event\n * @param {object} opts Options to pass to the event\n * @returns {boolean} The return value is <code>false</code> if event is cancelable and at least one of the event handlers which handled this event called <code>Event.preventDefault()</code>. Otherwise it returns <code>true</code>.\n */\nexport function emit (elem, name, opts = {}) {\n  const defs = {\n    bubbles: true,\n    cancelable: true,\n    composed: false\n  }\n  const eventOptions = Object.assign({}, defs, opts)\n  const e = new CustomEvent(name, eventOptions)\n  return elem.dispatchEvent(e)\n}\n"],"names":["waitFor","test","timeoutInMilliseconds","Promise","resolve","reject","check","result","Error","setTimeout","isPromise","obj","then","hasKey","key","Object","prototype","hasOwnProperty","call","elementEmpty","el","firstChild","removeChild","renderOutlet","what","where","outlet","document","querySelector","console","warn","element","Element","HTMLElement","isElement","window","customElements","get","createElement","html","div","innerHTML","trim","elementFromString","appendChild","dro","hasAttribute","setAttribute","Array","peek","this","length","flatten","stack","parentRouteStack","routes","clearParentRouteStack","forEach","route","children","newRoute","action","component","emptyRoute","find","r","path","filter","nr","copyRouteAndAdjustPath","push","flattenChildren","splice","last","stripTrailingSlash","charAt","slice","addMatcherToRoute","matcher","undefined","keys","match","urlParamKeys","map","k","substring","pathRegexStr","replace","pathRegex","RegExp","pathRegexCapture","params","v","exec","nv","i","UrlSearchOrHashParams","constructor","url","paramUrl","urlHash","urlParamMap","paramPairs","includes","indexOf","split","paramComponents","_esc","decodeURIComponent","entries","has","sort","entryA","entryB","toLowerCase","remove","set","val","toString","paramsString","entry","encodeURIComponent","_unesc","values","s","String","Stack","items","pop","isEmpty","clear","size","Router","rootOutletSelector","options","__ficusjs__","router","_rootOutletSelector","_routes","_processRoutes","_routerOptions","_processOptions","_outletCache","WeakMap","addEventListener","_findAndRenderRoute","location","catch","e","_renderError","loc","host","protocol","pathname","hash","href","search","state","history","mode","_getHashPathname","setOptions","addRoutes","hasRoute","_findRoute","_getQueryStringParams","fromEntries","_getUrlParams","flattenRoutes","opts","that","autoStart","changeHistoryState","warnOnMissingOutlets","resolveRoute","context","template","outlets","routeResolver","_render","_performRender","redirect","routerOutlet","ok","namedOutlets","querySelectorAll","o","_renderIntoOutlet","all","allOutlets","_renderIntoAllOutlets","_isSameOutletContent","_emitRouterOutletChangeEvent","routerOutlets","ro","elem","name","eventOptions","assign","bubbles","cancelable","composed","CustomEvent","dispatchEvent","emit","detail","_navigate","replaceHistory","thisLocation","_normalizeLocation","actionResult","_resolveRoute","_setState","err","from","_renderActionResult","URL","_getRouteContext","routeContext","replaceState","pushState","error","errorHandler","message","status","errorTemplate","go","n","goBack","goForward","start","readyState","createRouter","getRouter"],"mappings":"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"}